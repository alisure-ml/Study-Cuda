# Makefile

## 关于makefile

`makefile`带来直接好处就是——“自动化编译”。
一旦写好，只需要一个make命令，整个工程完全自动编译，所以十分方便。
而Makefile文件就是告诉make命令怎么样地去编译和链接程序。
但是想要比较灵活的运用它，还是先要熟悉一些关于系统对程序编译和链接的知识。

一般来说，对C、C++程序、先把源文件编译成中间代码文件。
Linux下是`.o`文件即Object File,在Windows下也就是`.obj`文件，这个动作叫做`编译`（compile）。
然后再把大量的`.O`文件合成执行文件，这个动作叫作`链接`（link）。

* 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。
对于后者，通常是告诉编译器头文件的所在位置（头文件中放声明，而定义放在C/C++文件中），
只要所有的语法正确，编译器就可以编译出中间目标文件。
一般来说，每个源文件都应该对应于一个中间目标文件（.O文件或是OBJ文件）。

* 链接时，主要是链接函数和全局变量。
我们可以使用这些中间目标文件（.O文件或.OBJ文件）来链接我们的应用程序。
链接器并不管函数所在的源文件，只管函数的中间目标文件。
在大多数时候，由于源文件太多，编译生成的中间目标文件太多，
而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，
所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，
也就是`.lib`文件，在Linux下，是Archive File，也就是`.a`文件。

总的来说就是:首先`源文件`->`.o文件`，再由`.o文件`->`可执行文件`。
在编译时，编译器只检测程序语法，和函数、变量是否被声明。
如果函数未被声明，编译器会给出一个警告，但可以生成Object File。
而在链接程序时，链接器会在所有的.o文件中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error）。


## Makefile 简介

`Makefile`是和`make`命令一起配合使用的.

很多大型项目的编译都是通过`Makefile`来组织的, 如果没有`Makefile`,
那很多项目中各种库和代码之间的依赖关系不知会多复杂。

### Makefile基本格式

> tab键必须是tab，不能是4个空格。

```
target ...: prerequisites ..
    command 
    ...
    ...
```

```
target : 目标文件，可以是Object File，也可以是可执行文件
prerequisites : 生成target所需要的文件或者目标
command : make需要执行的任何shell命令，命令必须以{tab}开头
```


### GNU make的工作方式

1. 读入主Makefile
2. 读入被include的其他Makefile
3. 初始化文件中的变量
4. 推导隐晦规则，并分析所有规则
5. 为所有的目标文件创建依赖关系链
6. 根据依赖关系，决定哪些目标要重新生成
7. 执行生成命令


### GNU约定俗成的伪目标

|伪目标|含义|
|:--:|:--:|
|all |所有目标的目标，一般是编译所有的目标 |
|clean |删除所有被make创建的文件 |
|install |安装已编译好的程序，把目标可执行文件拷贝到指定的目录中去 |
|print |列出改变过的源文件 |
|tar |把源程序打包备份 |
|dist |创建一个压缩文件.... |
|TAGS |更新所有的目标，以备完整地重变异使用 |
|check / test |一般用来策划死makefile的流程 |


## Reference

* [Linux——makefile编写](https://www.cnblogs.com/tp-16b/p/8955462.html)

* [【Linux】Makefile使用总结](https://blog.csdn.net/u012503639/article/details/78448158)


